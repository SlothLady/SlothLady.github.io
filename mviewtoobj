<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marmoset Mview to OBJ Converter (Geometry-Only)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #viewer {
            display: none;
            width: 100%;
            height: 500px;
            margin-top: 1.5rem;
            border-radius: 1rem;
            background-color: #1f2937;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl flex flex-col space-y-6">
        <div class="bg-gray-800 rounded-2xl shadow-2xl p-8 space-y-6">
            <div class="text-center">
                <h1 class="text-3xl font-bold text-white">Marmoset Mview to OBJ Converter</h1>
                <p class="text-gray-400 mt-2">Extracts geometry from a `.mview` file.</p>
            </div>

            <div class="relative border-2 border-dashed border-gray-600 rounded-lg p-6 text-center hover:border-indigo-500 transition-colors">
                <input type="file" id="fileInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" accept=".mview">
                <div class="flex flex-col items-center justify-center space-y-2">
                    <svg class="w-12 h-12 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M3 17.25V6.75A2.25 2.25 0 015.25 4.5h13.5A2.25 2.25 0 0121 6.75v10.5A2.25 2.25 0 0118.75 21H5.25A2.25 2.25 0 013 17.25z" />
                    </svg>
                    <p id="fileName" class="text-gray-400">Drag & drop or click to select a file</p>
                </div>
            </div>

            <button id="convertBtn" class="w-full bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-indigo-700 disabled:bg-gray-500 disabled:cursor-not-allowed transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-800" disabled>
                Convert and View
            </button>

            <div id="results" class="hidden space-y-4">
                <h2 class="text-xl font-semibold text-white">Conversion Complete</h2>
                <p class="text-gray-400">Your OBJ file is ready for download and viewing.</p>
                <div id="download-container" class="grid grid-cols-1 gap-4"></div>
            </div>
             <div id="viewer-container">
                <div id="viewer"></div>
            </div>
        </div>

        <div class="bg-gray-800 rounded-2xl shadow-2xl p-6">
            <h3 class="font-semibold text-white mb-2">Console</h3>
            <div class="bg-gray-900 p-4 rounded-lg">
                <pre id="log" class="text-sm text-gray-300 whitespace-pre-wrap max-h-48 overflow-y-auto"></pre>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const convertBtn = document.getElementById('convertBtn');
        const resultsDiv = document.getElementById('results');
        const downloadContainer = document.getElementById('download-container');
        const logOutput = document.getElementById('log');
        const viewerContainer = document.getElementById('viewer');

        // --- File Input Handling ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
                convertBtn.disabled = false;
            } else {
                fileNameDisplay.textContent = 'Drag & drop or click to select a file';
                convertBtn.disabled = true;
            }
        });

        // --- Logging ---
        function log(message) {
            console.log(message);
            logOutput.textContent += message + '\n';
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        // --- Conversion Logic ---
        convertBtn.addEventListener('click', async () => {
            const file = fileInput.files[0];
            if (!file) return;

            log(`Starting conversion of ${file.name}...`);
            resultsDiv.classList.add('hidden');
            downloadContainer.innerHTML = '';
            viewerContainer.style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const mview = new Uint8Array(arrayBuffer);

                log('Extracting files from mview archive...');
                const files = extractMview(mview);
                log(`Extracted ${Object.keys(files).length} files.`);

                if (files['scene.json']) {
                    const sceneJsonString = new TextDecoder().decode(files['scene.json']);
                    const sceneData = JSON.parse(sceneJsonString);
                    log('Processing scene.json...');

                    const { combinedObj } = extractModel(sceneData, files);

                    const objBlob = new Blob([combinedObj], { type: 'text/plain' });

                    createDownloadLink(objBlob, file.name.replace('.mview', '.obj'));
                    resultsDiv.classList.remove('hidden');

                    loadModelIntoViewer(objBlob);

                } else {
                    log('Error: scene.json not found in the mview file.');
                }

            } catch (error) {
                log(`An error occurred: ${error.message}`);
                console.error(error);
            }
        });

        // --- MVIEW Extraction ---
        function extractMview(mviewData) {
            const files = {};
            let offset = 0;
            const readCString = () => { let str = ''; while (offset < mviewData.length && mviewData[offset] !== 0) { str += String.fromCharCode(mviewData[offset]); offset++; } offset++; return str; };
            const readUint32 = () => { if (offset + 4 > mviewData.length) return 0; const val = new DataView(mviewData.buffer, offset, 4).getUint32(0, true); offset += 4; return val; };
            while (offset < mviewData.length) {
                const name = readCString(); if (!name) break;
                const ftype = readCString(); const c = readUint32(); const d = readUint32(); const e = readUint32();
                if (offset + d > mviewData.length) break;
                let data = mviewData.slice(offset, offset + d); offset += d;
                if (c & 1) { data = decompress(data, e); }
                if (data) { files[name] = data; }
            }
            return files;
        }

        function decompress(a, b) {
            const c = new Uint8Array(b); let d = 0; const e = new Uint32Array(4096); const f = new Uint32Array(4096); let g = 256; const h = a.length; let k = 0; let l = 1; if (h === 0) return null; c[d++] = a[0]; for (let r = 1; ; r++) { let n_offset = r + (r >> 1); if (n_offset + 1 >= h) break; let m_val = a[n_offset + 1]; let n_val = a[n_offset]; let p = (r & 1) ? (m_val << 4 | n_val >> 4) : ((m_val & 15) << 8 | n_val); if (p < g) { let m_new, n_new; if (p < 256) { m_new = d; n_new = 1; if (d < b) c[d++] = p; } else { m_new = d; n_new = f[p]; let p_orig = e[p]; let q = p_orig + n_new; for (let i = p_orig; i < q; i++) { if (d < b) c[d++] = c[i]; } } k = m_new; l = n_new; } else if (p === g) { let m_new = d; let n_new = l + 1; let q = k + l; for (let i = k; i < q; i++) { if (d < b) c[d++] = c[i]; } if (d < b) c[d++] = c[k]; k = m_new; l = n_new; } else { break; } if (g < 4096) { e[g] = k; f[g] = l; g++; } } return d === b ? c : null;
        }

        // --- Model Extraction ---
        function unpackNormal(short1, short2) {
            const sign = short2 >= 32768;
            if (sign) { short2 -= 32768; }
            let x = (short1 / 32767.4) * 2 - 1;
            let y = (short2 / 32767.4) * 2 - 1;
            let z_sq = 1.0 - (x * x + y * y);
            let z = Math.sqrt(z_sq > 0 ? z_sq : 0);
            if (sign) { z = -z; }
            return { x, y, z };
        }

        function extractModel(sceneData, files) {
            let combinedObj = '';
            let vertexOffset = 1;
            let normalOffset = 1;

            sceneData.meshes.forEach(mesh => {
                const name = mesh.name;
                const datFile = mesh.file;
                log(`Extracting geometry from ${datFile}...`);

                if (!files[datFile]) {
                    log(`Warning: Mesh data file ${datFile} not found.`);
                    return;
                }

                const dataView = new DataView(files[datFile].buffer);
                const indexTypeSize = mesh.indexTypeSize;
                const stride = 32 + (mesh.vertexColor ? 4 : 0) + (mesh.secondaryTexCoord ? 8 : 0);

                const vertList = [];
                const normalList = [];

                let indicesSize = mesh.indexCount * indexTypeSize;
                let vertexDataOffset = indicesSize + (mesh.wireCount * indexTypeSize);

                for (let v = 0; v < mesh.vertexCount; v++) {
                    let current_offset = vertexDataOffset + v * stride;

                    const position = new THREE.Vector3(
                        dataView.getFloat32(current_offset, true),
                        dataView.getFloat32(current_offset + 4, true),
                        dataView.getFloat32(current_offset + 8, true)
                    );
                    vertList.push(position);

                    let normalDataOffset = current_offset + 12 + 8 + 4 + 4;
                    const normShort1 = dataView.getUint16(normalDataOffset, true);
                    const normShort2 = dataView.getUint16(normalDataOffset + 2, true);
                    const unpacked = unpackNormal(normShort1, normShort2);
                    const normal = new THREE.Vector3(unpacked.x, unpacked.y, unpacked.z);
                    normalList.push(normal);
                }

                const currentVertexCount = vertList.length;
                const currentNormalCount = normalList.length;

                vertList.forEach(v => combinedObj += `v ${v.x} ${v.y} ${v.z}\n`);
                normalList.forEach(n => combinedObj += `vn ${n.x} ${n.y} ${n.z}\n`);

                mesh.subMeshes.forEach(subMesh => {
                    combinedObj += `\ng ${name}_${subMesh.material}\n`;

                    const faceCount = subMesh.indexCount / 3;
                    let faceOffset = subMesh.firstIndex * indexTypeSize;

                    for (let f = 0; f < faceCount; f++) {
                        let i1, i2, i3;
                        if (indexTypeSize === 2) {
                            i1 = dataView.getUint16(faceOffset, true);
                            i2 = dataView.getUint16(faceOffset + 2, true);
                            i3 = dataView.getUint16(faceOffset + 4, true);
                            faceOffset += 6;
                        } else {
                            i1 = dataView.getUint32(faceOffset, true);
                            i2 = dataView.getUint32(faceOffset + 4, true);
                            i3 = dataView.getUint32(faceOffset + 8, true);
                            faceOffset += 12;
                        }

                        const v1 = i1 + vertexOffset; const v2 = i2 + vertexOffset; const v3 = i3 + vertexOffset;
                        const n1 = i1 + normalOffset; const n2 = i2 + normalOffset; const n3 = i3 + normalOffset;

                        combinedObj += `f ${v1}//${n1} ${v2}//${n2} ${v3}//${n3}\n`;
                    }
                });

                vertexOffset += currentVertexCount;
                normalOffset += currentNormalCount;
            });

            return { combinedObj };
        }

        // --- UI and Download Helpers ---
        function createDownloadLink(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.textContent = `Download ${filename}`;
            a.className = "block text-center bg-green-600 text-white font-semibold py-2 px-3 rounded-lg hover:bg-green-700 transition-colors";
            downloadContainer.innerHTML = '';
            downloadContainer.appendChild(a);
        }

        // --- Three.js Viewer ---
        let scene, camera, renderer, controls;
        function initViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1f2937);
            camera = new THREE.PerspectiveCamera(75, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.innerHTML = '';
            viewerContainer.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        function onWindowResize() {
            if (!renderer) return;
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer) renderer.render(scene, camera);
        }
        function loadModelIntoViewer(objBlob) {
            viewerContainer.style.display = 'block';
            if (!renderer) { initViewer(); }

            while(scene.children.length > 0){
                const obj = scene.children[0];
                if (obj.isMesh) {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                }
                scene.remove(obj);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(5, 10, 7.5); scene.add(directionalLight);

            const objLoader = new THREE.OBJLoader();
            const objURL = URL.createObjectURL(objBlob);

            objLoader.load(objURL, (object) => {
                URL.revokeObjectURL(objURL);

                object.traverse(child => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0xcccccc,
                            side: THREE.DoubleSide,
                            metalness: 0.2,
                            roughness: 0.6
                        });
                    }
                });

                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3()).length();
                const center = box.getCenter(new THREE.Vector3());

                controls.reset();
                controls.target.copy(center);
                controls.maxDistance = size * 10;
                camera.near = size / 100;
                camera.far = size * 100;
                camera.updateProjectionMatrix();
                camera.position.copy(center);
                camera.position.x += size / 2.0;
                camera.position.y += size / 5.0;
                camera.position.z += size / 2.0;
                camera.lookAt(center);

                scene.add(object);
                log('Model loaded into viewer.');
            }, undefined, (error) => {
                URL.revokeObjectURL(objURL);
                log('Error loading OBJ file: ' + error);
                console.error(error);
            });
        }
    </script>
</body>
</html>
